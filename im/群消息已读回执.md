### 消息表设计

群消息数据表：

group_msgs(msgid, gid, sender_uid, time, content);

各字段的含义为：消息ID，群ID，发送方UID，发送时间，发送内容

**群成员表：**记录群里的成员，以及每个成员收到的最后一条群消息

group_users(gid, uid, last_ack_msgid);

其中`last_ack_msgid`是群成员收到的最后一条消息, 在线的user会很快回复ack, 更新该msgid；

离线的user会在下次登录成功, 建立连接后，批量拉取到该消息更新该msgid。

【如果该msgid消息有可能会拉到重复的消息，需要在客户端去重】

> 上报消息已读：PutAdviceOfReadByMsgId，群聊最后一条消息

### 已读回执实现

消息回执表：用来记录消息的已读回执

msg_acks(sender_uid, msgid, recv_uid, gid,if_ack);

各字段的含义为：发送方UID，消息ID，回执方UID，群ID，回执标记

https://www.jianshu.com/p/03c161886f25



从业务层面弱化离线和在线的区别，群消息表内只存1条消息，send_id, group_id, msg_id。离线用户登录后不会拉取离线消息，只会获取所有会话的最新msgid或者时间，只有当用户进入特定的聊天界面时，才会实时触发拉取消息流程，此时根据最新msgid分页往前倒推获取，没有截止时间点，只要用户在界面上拉刷新，就会获取上一页msg。
1.这里其实是获取历史消息，将离线消息拉取场景也当做了历史消息拉取的一种
2.实时触发拉取，因为就算是登录时拉取了离线消息，也只有在用户点击进去相应的聊天界面这些消息才有用处（即用户点进去看这些消息）
3.假设有大量离线客户端同时登录，这里将登录时的大量统一拉取分散到了登录后的实时拉取，理论上应该是分散和随机的，可减少服务端的瞬时请求量