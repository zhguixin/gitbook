《深入理解JVM虚拟机》笔记

### JVM内存划分

Java虚拟机在运行程序的时候，会把分配给他管理的内存区域再划分为几个：

* 方法区，保存类信息、常量、静态变量；这块内存是线程共享的

* JVM堆，这个是JVM所管理的最大的一块内存，new出来的对象都存放于此处，Java的垃圾收集器就是管理的这块内存。这块内存是线程共享的

* 程序计数器，字节码指令存储区，线程私有

* 虚拟机栈，在执行Java方法调用时会创建对应的一个栈帧，这个栈帧就存储在虚拟机栈中，显然这块内存是线程私有的

  > 栈帧，里面存储的是：变量表、操作数栈、返回值、返回地址等。函数调用对应栈帧的入栈；函数调用结束对应栈帧的出栈。

* 本地方法栈，主要是与虚拟机调用Native方法相关（JNI），这块内存区域是线程私有的

### GC内存回收机制

* 引用计数，无法处理循环引用
* 可达性分析，这是JVM采取内存回收机制

GC Root的选择

* 局部变量表中引用的对象
* 本地方法栈中引用的变量
* 常量池中引用的对象
* Class对象引用的变量



内存清理，减少内存碎片：

* 标记-清理，适用于存活对象多，垃圾少的情况；（老年代，对象不会轻易被回收）

* 复制，适用于存活对象少，垃圾多的情况。（新生代，对象回收频繁）

  内存区域划分为：`8:1:1`，依次取名为 `Eden`、`Survivor A`、`Survivor B` 区

### 第五部分，高效并发

#### Java内存模型

Java内存模型即Java Memory Model，简称JMM。JMM定义了Java 虚拟机(JVM)在计算机内存(RAM)中的工作方式。程序中的变量存储在主内存中，每个线程拥有自己的工作内存并存放变量的拷贝，线程读写自己的工作内存，通过主内存进行变量的交互。JMM就是规定了工作内存和主内存之间变量访问的细节，通过保障原子性、有序性、可见性来实现线程的有效协同和数据的安全。

Java内存模型规定了所有的变量都存储在主内存中， 每条线程还有自己的工作内存，线程的工作内存中保存了被该线程使用到的变量的主内存副本拷贝（并不会全部拷贝。只会拷贝需要的某个字段），线程对变量的所有操作（读取、 赋值等）都必须在工作内存中进行，而不能直接读写主内存中的变量 。

> 其中变量指的是，包括了实例字段、 静态字段和构成数组对象的元素，但不包括局部变量与
> 方法参数，因为后者是线程私有的，不会被共享，自然就不会存在竞争问题 。

#### volatile变量的理解

由于Java内存模型的限定导致变量在多个线程中的操作具有“不可见性”，为此Java中volatile变量来保证变量在各个线程中都是可见的。这是轻量的保证线程安全的机制。但是由于有一些操作**并不是原子操作**(也就无法保证线程安全)，比如++自增操作，对volatile标识的变量也不一定能达到最终想要的结果。

> volatile只是保证操作的是同一块内存区域，但是自增操作，是由多个非原子操作组合而成的复合操作。

比如开启1000个线程，每个线程都对变量count进行自增操作，等待所有线程结束后，打印count的值，结果不一定为1000；

```java
volatile int count = 0;

// tip， 等待所有线程结束
while(Thread.activeCount() > 1) {
  Thread.yield();
}
```

volatile的一个使用场景：线程A中，进行初始化操作，初始化完成后设置flag标识初始化完成，线程B等待该初始化完成的标识进入下一步操作。

```java
boolean flag;

// thread A 初始化操作，置标志位位true
....
flag = true;

// thread B 等待标志位是否为true，从而确定是否可以进入下一操作
while(!flag) {
  ...
}
doOtherThing();
```

但是指令重排会导致`flag = true`会提前执行，从而导致线程B误认为初始化已经完成。

正确的做法就是加上`volatile`关键字。对于加上`volatile`的变量，赋值时会多出一条指令：

```assembly
lock add $0x0, (%esp)
```

该指令加了一个**内存屏障**，防止后面的指令重排到内存屏障之前的位置。

#### Sychronized关键字的理解

Sychronized可以方法和代码段。

Sychronized修饰代码段，某一时刻只允许一个线程访问，该段代码结束后，会将变量值写入主内存。是会造成线程阻塞的。



