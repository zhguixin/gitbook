JVM字节码执行引擎

Java虚拟机的执行引擎的过程是：输入字节码文件，解析字节码，输出执行结果。

#### 栈帧

栈帧是用于支持虚拟机进行方法调用和方法执行的数据结构。Java中每一个方法的调用对应着栈帧在虚拟机中入栈出栈的过程。位于栈顶的栈帧称为当前栈帧，与之关联的方法为当前方法。

栈帧的主要组成部分有：

* 局部变量表，一段变量存储空间，存放方法参数和方法内部定义的局部变量表。局部变量在字节码加载中没有“准备阶段”。

  栈帧中局部变量表引用的对象可以作为GC Roots。

  > 类变量在JVM加载过程中，会经历两个阶段：准备阶段，此时赋予系统初值；初始化阶段，赋予程序分配的值。因此，即使在初始化阶段程序员没有为类变量赋初值也没有关系，类变量仍然具有一个确定的初始值。

* 操作数栈，各种字节码指令会向操作数栈中写入和提取内容。操作数栈中传递数据类型必须与字节码指令的序列严格匹配。比如，执行iadd指令时，操作数栈最接近栈顶的两个元素的数据类型必须是int

* 动态连接，运行时将常量池中的符号引用变为直接引用

* 返回地址，一个方法执行完毕后的返回地址，有返回值要传递给上层方法调用者。


#### 方法调用

常用的方法调用指令：

* invokestatic
* invokespecial，调用实例构造器<init>方法、私有方法和父类方法
* invokevirtual，调用所有的虚方法
* invokeinterface，
* invokedynamic，

invokestatic、invokespecial在字节码解析阶段就可以确定方法的唯一调用版本。

> final方法虽然被invokevirtual指令调用，但是仍然可以在解析阶段确认

方法的调用，有解析和分派两种过程。

* 解析，调用的目标方法在编译时就已经确定好了，比如静态方法和私有方法
* 分派，又分为静态分配与动态分配

```java
Human man = new Man();
```

Human是静态类型，编译时确定；Man是实际类型，运行时确定。虚拟机(实际上都不要虚拟机参与，编译器都确定好了)在**重载时是通过参数的静态类型而不是实际类型作为判定依据的**。

> 重载的时候虚拟机会选择一个做合理的方法，牵涉到自动转型：char->int->long->float->double

动态分配，与多态性有密切的关系。通过一个接口调用某个方法时，要确定调用哪个具体的方法就需要运行时来确定。

#### 基于栈的字节码解释执行引擎

基于栈的指令集主要优点是平台无关性，可移植；指令集紧凑。缺点就是完成相同的功能所需要的指令数量要比基于寄存器的指令集多，频繁的栈访问也意味着频繁的内存访问。